#!/usr/bin/env python3
# Copyright 2023 The Lynx Authors. All rights reserved.
# Licensed under the Apache License Version 2.0 that can be found in the
# LICENSE file in the root directory of this source tree.



"""
usage: gn_to_cmake.py [-h] --json-path JSON_PATH --start-target START_TARGET [--cmake-version CMAKE_VERSION] [--project-name PROJECT_NAME] [--compiler-target COMPILER_TARGET]
                      [--keep-libs KEEP_LIBS [KEEP_LIBS ...]] [--flavor-name FLAVOR_NAME]

A project.json file should be generated by gn before using this script!!!

The command of 'gn gen OUTPUT_PATH --ide=json' will generate the project.json file. 
This json file contain compile flags, link flags, dependencies, defines and so on. 
This script will convert the content of project.json to some CMakeLists file.
"""

import argparse
import json
import logging
import os
import posixpath
import string
import sys

DEFAULT_CMAKE_MIN_VERSION = '3.4.1'
DEFAULT_GN_COMPILER_TARGET = '//:gen_basic_compiler_flags'
DEFAULT_USE_PATH_PREFIX = True


def cmake_string_escape(a):
  """Escapes the string 'a' for use inside a CMake string.

  This means escaping
  '\' otherwise it may be seen as modifying the next character
  '"' otherwise it will end the string
  ';' otherwise the string becomes a list

  The following do not need to be escaped
  '#' when the lexer is in string state, this does not start a comment
  """
  return a.replace('\\', '\\\\').replace(';', '\\;').replace('"', '\\"')

def cmake_target_escape(a):
  """Escapes the string 'a' for use as a CMake target name.

  CMP0037 in CMake 3.0 restricts target names to "^[A-Za-z0-9_.:+-]+$"
  The ':' is only allowed for imported targets.
  """
  def Escape(c):
    if c in string.ascii_letters or c in string.digits or c in '_.+-':
      return c
    return '__'

  return ''.join([Escape(c) for c in a])

def find_first_of(s, a):
  return min(s.find(i) for i in a if i in s)

def get_cmake_target_name(gn_target_name):
  path_separator = find_first_of(gn_target_name, (':', '('))
  location = None
  name = None
  toolchain = None
  if not path_separator:
    location = gn_target_name[2:]
  else:
    location = gn_target_name[2:path_separator]
    toolchain_separator = gn_target_name.find('(', path_separator)
    if toolchain_separator == -1:
      name = gn_target_name[path_separator + 1:]
    else:
      if toolchain_separator > path_separator:
        name = gn_target_name[path_separator + 1:toolchain_separator]
      assert gn_target_name.endswith(')')
      toolchain = gn_target_name[toolchain_separator + 1:-1]
  assert location or name

  cmake_target_name = None
  if location.endswith('/' + name):
    cmake_target_name = location
  elif location:
    cmake_target_name = location + '_' + name
  else:
    cmake_target_name = name
  if toolchain:
    cmake_target_name += '--' + toolchain
  return cmake_target_escape(cmake_target_name)

def instead_source_path_prefix_list(project, paths_list):
  return [path.replace(project.root_path, "${ROOT_PATH}") for path in paths_list]

class Project:
  def __init__(self, project_json, project_name, start_target_name, cmake_version, parent):
    self.name = project_name
    self.cmake_version = cmake_version
    self.targets = project_json['targets']
    self.build_settings = project_json['build_settings']
    self.root_path = self.build_settings['root_path']
    self.build_path = os.path.join(self.root_path,
                                     self.build_settings['build_dir'][2:])
    
    self.start_target = Target(start_target_name, self)
    self.parent_project = parent

  def find_all_dependencies(self, start_target):
    """
    Find all dependencies starting with start_target
    """
    all_targets = {}
    all_targets[start_target.gn_name] = start_target
    r = self.recursive_find_dependent_targets(start_target, start_target, all_targets)
    targets_list = []
    for key in all_targets.keys():
      targets_list.append(all_targets[key])
    targets_list.sort(key=lambda t: t.gn_name)
    return targets_list
  
  def recursive_find_dependent_targets(self, main_target, cur_target, all_targets):
    """
    Recursive search
    """
    if not cur_target.gn_name in self.targets.keys():
      logging.info('Can not find target %s' % (cur_target.gn_name))
      return -1
    all_targets[cur_target.gn_name] = cur_target
    deps = cur_target.properties.get('deps', [])
    if cur_target.gn_type == 'shared_library' and main_target.gn_name != cur_target.gn_name:
      # Dependencies on dynamic libraries do not add target dependencies directly, but instead rely on .so file
      deps = []
    if deps == []:
      return 0
    else:
      for dep in deps:
        dep_target = Target(dep, self)
        r = self.recursive_find_dependent_targets(main_target, dep_target, all_targets)
        if r != 0:
          return r
      return 0
    
  def find_all_user_defines(self, compiler_target, target_list):
    """
    Find custom macros
    """
    all_defines = set()
    for target in target_list:
      defines = target.properties.get('defines', [])
      all_defines.update(defines)
    base_defines = set(compiler_target.properties.get('defines', []))
    all_defines = all_defines.difference(set(base_defines))
    return all_defines
  
  def find_all_include_dirs(self, target_list):
    all_includes = set()
    for target in target_list:
      includes = target.properties.get('include_dirs', [])
      for include in includes:
        all_includes.add(self.get_absolute_path(include))
    include_dirs = list(all_includes)
    include_dirs.sort()
    all_head_includes = self.start_target.metadata.ahead_includes
    ahead_includes = []
    for ahead_include in all_head_includes:
      ahead_includes.append(self.get_absolute_path(ahead_include))
    return ahead_includes + include_dirs
  
  def find_dependent_shared_targets(self, target_list):
    result = []
    for target in target_list:
      is_parent_target = self.parent_project and target.gn_name == self.parent_project.start_target.gn_name
      if is_parent_target:
        # Parent cmake target can be linked directly by name
        continue
      is_share_lib = target.gn_type == 'shared_library' and target.gn_name != self.start_target.gn_name
      if is_share_lib:
        # Dependencies on dynamic libraries do not add target dependencies directly, but instead rely on .so file
        result.append(target)
    return result
  
  def find_all_sources(self, target_list):
    """
    Source target name and sources list
    """
    sources_dict = {}
    has_asm = False
    for target in target_list:
      if target.cmake_type.modifier == 'SOURCES':
        continue
      if type(target) != Target:
        logging.error('target is not type of Target')
        continue
      sources = target.properties.get('sources', [])
      sources_path = []
      target_name = target.cmake_name + '_sources'
      for source in sources:
        _, ext = posixpath.splitext(source)
        source_abs_path = self.get_absolute_path(source)
        sources_path.append(source_abs_path)
        if source_file_types.get(ext, 'other') == 'asm':
          has_asm = True
      if len(sources) > 0:
        sources_path.sort()
        sources_dict[target_name] = sources_path
    return sources_dict, has_asm
  
  def find_all_prebuild_action_targets(self, target_list, parent_action_targets):
    """
    Just handle type of 'action'
    """
    parent_action_targets_name = [target.gn_name for target in parent_action_targets]
    result = []
    for target in target_list:
      type_condition = target.gn_type == 'action'
      # Filter parent script target in subdirectory
      name_condition = not target.gn_name in parent_action_targets_name
      if type_condition and name_condition:
        result.append(target)
    return result
  
  def find_all_libs(self, start_target, target_list, compiler_target, keep_libs):
    """
    Find system dependent libs and custom dependent libs
    """
    base_libs = set(compiler_target.properties.get('libs', []))
    base_libs = base_libs.difference(set(keep_libs))
    base_lib_dirs = set(compiler_target.properties.get('lib_dirs', []))
    full_path_libs = set()
    no_path_libs = set()
    for target in target_list:
      if type(target) != Target:
        logging.error('target is not type of Target')
        continue
      if target.gn_type == 'shared_library' and target.gn_name != start_target.gn_name:
        full_path_libs.add(target.output_name)

    external_libraries = start_target.properties.get('libs', [])
    library_dirs = start_target.properties.get('lib_dirs', [])
    dirs = []
    if library_dirs:
      for dir in library_dirs:
        if dir in base_lib_dirs:
          continue
        dirs.append(self.get_absolute_path(dir))
    for external_library in external_libraries:
      if external_library in base_libs:
        continue
      if '/' in external_library:
          full_path_libs.add(self.get_absolute_path(external_library))
      else:
        is_custom_lib = False
        for dir in library_dirs:
          full_path = self.get_absolute_path(dir)
          if not os.path.exists(full_path):
            continue
          
          find = False
          for file_name in os.listdir(full_path):
            if file_name.endswith('.so'):
              if external_library == file_name[3:-3]:
                external_library = os.path.join(full_path, file_name)
                full_path_libs.add(external_library)
                find = True
            elif file_name.endswith('.a'):
              if external_library == file_name[3:-2]:
                external_library = os.path.join(full_path, file_name)
                full_path_libs.add(external_library)
                find = True
          if find:
            is_custom_lib = True
            break
        if is_custom_lib:
          continue
        no_path_libs.add(external_library)

    additional_target_link_libraries = set(self.start_target.metadata.additional_target_link_libraries)
    if len(additional_target_link_libraries) > 0:
      full_path_libs |= additional_target_link_libraries

    return full_path_libs, no_path_libs
  
  def find_custom_flags(self, start_target, compiler_target):
    asm = start_target.properties.get('asmflags', [])
    cflags = start_target.properties.get('cflags', [])
    cflags_c = start_target.properties.get('cflags_c', [])
    cflags_cxx = start_target.properties.get('cflags_cc', [])
    ldflags = start_target.properties.get('ldflags', [])
    base_asm = compiler_target.properties.get('asmflags', [])
    base_cflags = compiler_target.properties.get('cflags', [])
    base_cflags_c = compiler_target.properties.get('cflags_c', [])
    base_cflags_cxx = compiler_target.properties.get('cflags_cc', [])
    base_ldflags = compiler_target.properties.get('ldflags', [])

    result = {}
    result['asmflags'] = self.strip_base_flags(asm, base_asm)
    result['cflags'] = self.strip_base_flags(cflags, base_cflags)
    result['cflags_c'] = self.strip_base_flags(cflags_c, base_cflags_c)
    result['cflags_cc'] = self.strip_base_flags(cflags_cxx, base_cflags_cxx)
    result['ldflags'] = self.strip_base_flags(ldflags, base_ldflags)
    return result
  
  def get_absolute_path(self, path):
    if path.startswith("//"):
      return self.root_path + "/" + path[2:]
    return path
  
  def strip_base_flags(self, flags, base_flags):
    result = []
    tmp = {}
    for flag in flags:
      has_scan = tmp.get(flag, False)
      if flag in base_flags and not has_scan:
        tmp[flag] = True
        continue
      result.append(flag)
    return result

class CMakeTargetType:
  def __init__(self, command, modifier, property_modifier, is_linkable):
    self.command = command
    self.modifier = modifier
    self.property_modifier = property_modifier
    self.is_linkable = is_linkable
CMakeTargetType.custom = CMakeTargetType('add_custom_target', 'SOURCES',
                                         None, False)

# See GetStringForOutputType in gn
cmake_target_types = {
  'unknown': CMakeTargetType.custom,
  'group': CMakeTargetType.custom,
  'executable': CMakeTargetType('add_executable', None, 'RUNTIME', True),
  'loadable_module': CMakeTargetType('add_library', 'MODULE', 'LIBRARY', True),
  'shared_library': CMakeTargetType('add_library', 'SHARED', 'LIBRARY', True),
  'static_library': CMakeTargetType('add_library', 'STATIC', 'ARCHIVE', True),
  'source_set': CMakeTargetType('add_library', 'OBJECT', None, False),
  'copy': CMakeTargetType.custom,
  'action': CMakeTargetType.custom,
  'action_foreach': CMakeTargetType.custom,
  'bundle_data': CMakeTargetType.custom,
  'create_bundle': CMakeTargetType.custom,
}

cmake_link_flags_tags = {
  'unknown': 'CMAKE_SHARED_LINKER_FLAGS',
  'executable': 'CMAKE_EXE_LINKER_FLAGS',
  'shared_library': 'CMAKE_SHARED_LINKER_FLAGS',
  'static_library': 'CMAKE_STATIC_LINKER_FLAGS',
}

source_file_types = {
  '.cc': 'cxx',
  '.cpp': 'cxx',
  '.cxx': 'cxx',
  '.c': 'c',
  '.s': 'asm',
  '.S': 'asm',
  '.asm': 'asm',
  '.o': 'obj',
  '.obj': 'obj',
}

class Target:
  def __init__(self, gn_name, project):
    self.gn_name = gn_name
    self.properties = project.targets[self.gn_name]
    self.cmake_name = get_cmake_target_name(self.gn_name)
    self.gn_type = self.properties.get('type', None)
    self.cmake_type = cmake_target_types.get(self.gn_type, None)
    self.output_name = self.properties.get('output_name', '')
    self.metadata = Metadata(self.properties)

  def get_target_flags(self):
    print('')

class Metadata:
  def __init__(self, properties):
    metadata = properties.get('metadata', {})
    self.subdirectory_targets = metadata.get('subdirectory_targets', [])
    self.additional_target_link_libraries = metadata.get('additional_target_link_libraries', [])
    self.need_strip_symbol = False if (metadata.get('strip_symbol', None) == None) else True
    self.ahead_includes = metadata.get('ahead_includes', [])
    self.find_and_link_packages = metadata.get('find_and_link_packages', {})
    self.add_compile_options = metadata.get('add_compile_options', [])
    self.target_compile_options = metadata.get('target_compile_options', [])


class Writer:
  def __init__(self, output_path):
    dir = os.path.dirname(output_path)
    if not os.path.exists(dir):
      os.makedirs(dir)
    self.out = open(output_path, 'w+')

  def write_header_info(self, project):
    self.out.write('# Automatically generated by gn_to_cmake.py\n')
    self.out.write('# Please modify configs of compilation in the appropriate BUILD.gn\n')
    self.out.write('\n')
    self.out.write('# Set the minimum version of CMAKE that is required\n')
    self.out.write('cmake_minimum_required(VERSION %s)\n' % project.cmake_version)
    if project.name:
      self.out.write('project (%s)\n' % project.name)
    self.out.write('\n\n')

  def write_defines(self, defines):
    define_list = list(defines)
    define_list.sort()
    for define in define_list:
      define = define.replace(' ', '')
      self.out.write('add_definitions(')
      self.out.write('-D'+define)
      self.out.write(')\n')
    self.out.write('\n')

  def write_cmake_root_path(self, module_path):
    sub_dir = ''
    if module_path:
      dir_level = module_path.count('/') + 1
      for i in range(dir_level):
        sub_dir += '/..'
    root_path = '${CMAKE_CURRENT_SOURCE_DIR}' + sub_dir
    self.out.write('set(ROOT_PATH %s)\n\n' % root_path)

  def write_include_dirs(self, project, include_dirs, use_path_prefix):
    if use_path_prefix:
      include_dirs = instead_source_path_prefix_list(project, include_dirs)
    self.write_variable_list('include_directories', None, include_dirs)

  def write_dependent_shared_targets(self, targets, flavor_name, project, use_path_prefix):
    for target in targets:
      opt_str = 'noasan'
      if flavor_name == 'asan':
        opt_str = flavor_name
      mid_path = opt_str + '${CMAKE_BUILD_TYPE}'
      output_name = target.output_name
      target_path = project.get_absolute_path(target.gn_name.split(':')[0])
      target_path = os.path.join(target_path, 'build', 'intermediates', 'cmake', mid_path, 'obj', '${CMAKE_ANDROID_ARCH_ABI}')
      target_path = os.path.join(target_path,  'lib%s.so' % output_name)
      if use_path_prefix:
        target_paths = instead_source_path_prefix_list(project, [target_path])
      add_lib_str = 'add_library(%s SHARED IMPORTED)\n' % output_name
      self.out.write(add_lib_str)
      self.out.write('\n')
      self.write_current_target_property(output_name, "IMPORTED_LOCATION", target_paths, '')

  def write_all_sources(self, project, sources_dict, cmake_name, use_path_prefix):
    source_targets = self.write_sources(project, sources_dict, use_path_prefix)
    self.write_depend_sources(source_targets, cmake_name)

  def write_sources(self, project, sources_dict, use_path_prefix):
    source_targets = []
    for target_name in sources_dict.keys():
      source_targets.append(target_name)
      sources_path = sources_dict[target_name]
      if use_path_prefix:
        sources_path = instead_source_path_prefix_list(project, sources_path)
      self.write_variable_list('set', target_name, sources_path)
    return source_targets

  def write_depend_sources(self, source_targets, cmake_name):
    self.out.write('file(GLOB ')
    self.out.write(cmake_name)
    self.out.write('\n  ')
    self.out.write('\n  '.join([cmake_string_escape('${'+value+'}') for value in source_targets]))
    self.out.write(')\n\n')
  
  def write_enable_asm(self, has_asm):
    if has_asm:
      self.out.write('enable_language(ASM)\n\n')

  def write_prebuild_actions(self, action_targets, project, use_path_prefix):
    for target in action_targets:
      if type(target) != Target:
        continue
      self.write_single_variable('set', 'action_target', target.cmake_name)
      sources = target.properties.get('sources', [])
      sources_path = []
      for source in sources:
        source_abs_path = project.get_absolute_path(source)
        sources_path.append(source_abs_path)
      if use_path_prefix:
        sources_path = instead_source_path_prefix_list(project, sources_path)
      source_target_name =  '${action_target}__sources'
      self.write_variable_list('set', source_target_name, sources_path)

      outputs = []
      output_directories = set()
      for output in target.properties.get('outputs', []):
        output_abs_path = project.get_absolute_path(output)
        outputs.append(output_abs_path)
        output_directory = posixpath.dirname(output_abs_path)
        if output_directory:
          output_directories.add(output_directory)
      if use_path_prefix:
        outputs = instead_source_path_prefix_list(project, outputs)
        output_directories = instead_source_path_prefix_list(project, output_directories)
      outputs_name = '${action_target}__output'
      self.write_variable_list('set', outputs_name, outputs)

      self.out.write('add_custom_command(OUTPUT ')
      self.write_cmake_variable(outputs_name)
      self.out.write('\n')

      if output_directories:
        self.out.write('  COMMAND ${CMAKE_COMMAND} -E make_directory "')
        self.out.write('" "'.join([cmake_string_escape(d) for d in output_directories]))
        self.out.write('"\n')
      
      script = project.get_absolute_path(target.properties['script'])
      if use_path_prefix:
        script = script.replace(project.root_path, "${ROOT_PATH}")
      arguments = target.properties['args']
      self.out.write('  COMMAND python3 "')
      self.out.write(cmake_string_escape(script))
      self.out.write('"')
      if arguments:
        self.out.write('\n    "')
        self.out.write('"\n    "'.join([cmake_string_escape(a) for a in arguments]))
        self.out.write('"')
      self.out.write('\n')

      self.out.write('  DEPENDS ')
      self.write_cmake_variable(source_target_name, ' ')
      self.out.write('\n')

      build_path = project.build_path
      if use_path_prefix:
        build_path = build_path.replace(project.root_path, "${ROOT_PATH}")
      self.out.write('  WORKING_DIRECTORY "')
      self.out.write(cmake_string_escape(build_path))
      self.out.write('"\n')
      self.out.write('  COMMENT "Action: ${action_target}"\n')
      self.out.write('  VERBATIM)\n')

      self.out.write(target.cmake_type.command)
      self.out.write('(${action_target}')
      if target.cmake_type.modifier is not None:
        self.out.write(' ')
        self.out.write(target.cmake_type.modifier)
      source_target_name =  '${action_target}__sources'
      self.write_cmake_variable(source_target_name, ' ')
      self.out.write(' DEPENDS')
      self.write_cmake_variable(outputs_name, ' ')
      self.out.write(')\n\n')

      other_libraries = set()
      dependencies = set(target.properties.get('deps', []))
      for dependency in dependencies:
        gn_dependency_type = self.project.targets.get(dependency, {}).get('type', None)
        cmake_dependency_type = cmake_target_types.get(gn_dependency_type, None)
        cmake_dependency_name = get_cmake_target_name(dependency)
        if cmake_dependency_type.command != 'add_library':
          other_libraries.add(cmake_dependency_name)
        elif cmake_dependency_type.modifier != 'OBJECT':
          if not target.cmake_type.is_linkable:
            other_libraries.add(cmake_dependency_name)
      if other_libraries:
        self.out.write('add_dependencies("${action_target}"')
        for other_library in other_libraries:
          self.out.write('\n  "')
          self.out.write(other_library)
          self.out.write('"')
        self.out.write(')\n\n')
      self.out.write('\n')

  def write_all_libs(self, project, full_path_libs, no_path_libs, output_name, use_path_prefix):
    if len(no_path_libs) > 0:
      no_path_libs_list = list(no_path_libs)
      no_path_libs_list.sort()
      for lib in no_path_libs_list:
        name = lib + '-lib'
        full_path_libs.add('${' + name + '}')
        self.out.write('find_library(')
        self.out.write(cmake_string_escape(name))
        self.out.write(' ')
        self.out.write(cmake_string_escape(lib))
        self.out.write(')\n')
      self.out.write('\n')
    if len(full_path_libs) > 0:
      all_libs = list(full_path_libs)
      if use_path_prefix:
        all_libs = instead_source_path_prefix_list(project, all_libs)
      all_libs.sort()
      self.write_variable_list('target_link_libraries', output_name, all_libs)

  def write_main_target(self, main_target, all_script_targets):
    if type(main_target) != Target:
      return
    cmake_type = main_target.cmake_type
    self.out.write('\n# Main target\n')
    self.out.write('%s(' % cmake_type.command)
    self.out.write(main_target.output_name)
    if cmake_type.modifier is not None:
      self.out.write(' %s' % cmake_type.modifier)
    self.out.write(' ${')
    self.out.write(main_target.cmake_name)
    self.out.write('})\n\n')
    
    script_names = []
    for st in all_script_targets:
      script_names.append(st.cmake_name)
    if len(script_names) > 0:
      self.write_variable_list('add_dependencies', main_target.output_name, script_names)

  def write_target_compile_options(self, target_compile_options, output_name):
    flags = target_compile_options
    if flags and len(flags) > 0:
      for flag in flags:
        self.out.write('target_compile_options(%s PUBLIC %s)\n' % (output_name, flag))
      self.out.write('\n')

  def write_add_compile_options(self, add_compile_options):
    if add_compile_options and len(add_compile_options) > 0:
      self.write_variable_list('add_compile_options', '', add_compile_options)

  def write_subdirectory(self, subdirectory_targets, project, use_path_prefix):
    if len(subdirectory_targets) > 0:
      self.out.write('\n# subdirectory')
    for sub in subdirectory_targets:
      target = Target(sub, project)
      path = project.get_absolute_path(sub.split(':')[0])
      if use_path_prefix:
        path = path.replace(project.root_path, "${ROOT_PATH}")
      output_name = target.output_name
      self.out.write('\n')
      self.out.write('add_subdirectory(%s %s)\n' % (path, output_name))
    self.out.write('\n')

  def write_find_package_and_link(self, target, find_and_link_packages):
    if len(find_and_link_packages) > 0:
      for package in find_and_link_packages:
        self.out.write('find_package(%s)\n' % package[0])
        self.out.write('target_link_libraries(%s ${%s})\n' % (target.output_name, package[1]))

  def write_compiler_and_linker_flags(self, start_target, all_flags):
    asm = all_flags.get('asmflags', [])
    cflags = all_flags.get('cflags', [])
    cflags_c = all_flags.get('cflags_c', [])
    cflags_cxx = all_flags.get('cflags_cc', [])
    ldflags = all_flags.get('ldflags', [])
    c_flags = []
    c_flags.extend(cflags)
    c_flags.extend(cflags_c)
    cc_flags = []
    cc_flags.extend(cflags)
    cc_flags.extend(cflags_cxx)
    ld_flags = []
    ld_flags.extend(ldflags)
    if (len(c_flags) > 0 or len(cc_flags) > 0 or len(ld_flags) > 0):
      self.out.write('# Compiler and Linker flags\n')
    if (len(c_flags)>0):
      self.write_files_property('CMAKE_C_FLAGS', c_flags, ' ')
    if (len(cc_flags)>0):
      self.write_files_property('CMAKE_CXX_FLAGS', cc_flags, ' ')
    if (len(ld_flags)>0 and start_target.gn_type != 'static_library'):
      self.write_files_property(cmake_link_flags_tags.get(start_target.gn_type, 'CMAKE_SHARED_LINKER_FLAGS'), ld_flags, ' ')

  def write_strip_symbol(self, need_strip, output_name):
    if not need_strip:
      return
    command_path = '\"${ANDROID_TOOLCHAIN_ROOT}/bin/llvm-strip${ANDROID_TOOLCHAIN_SUFFIX}\"'
    self.out.write('set(CMAKE_STRIP ')
    self.out.write(command_path)
    self.out.write(')\n')
    self.out.write('message(STATUS "use ${CMAKE_STRIP}")\n')
    self.out.write('add_custom_command(TARGET ')
    self.out.write(output_name)
    self.out.write(' POST_BUILD\n')
    self.out.write('    COMMAND ${CMAKE_STRIP} --strip-unneeded $<TARGET_FILE:')
    self.out.write(output_name)
    self.out.write('>)\n')
    
  # helper method
  def write_single_variable(self, type, variable_name, value):
    """Sets a CMake variable."""
    self.out.write(type)
    if variable_name:
      self.out.write('(')
      self.out.write(cmake_string_escape(variable_name))
      self.out.write(' \n  ')
    else:
      self.out.write('(')
    self.out.write(cmake_string_escape(value))
    self.out.write('\n  )\n\n')

  def write_variable_list(self, type, variable_name, values):
    """Sets a CMake variable to a list."""
    if not values:
      self.write_single_variable(type, variable_name, "")
      return
    if len(values) == 1:
      self.write_single_variable(type, variable_name, values[0])
      return
    self.out.write(type)
    if variable_name:
      self.out.write('(')
      self.out.write(cmake_string_escape(variable_name))
      self.out.write('\n  ')
    else:
      self.out.write('(\n  ')
    self.out.write('\n  '.join([cmake_string_escape(value) for value in values]))
    self.out.write('\n  )\n\n')

  def write_files_property(self, property_name, values, sep):
    """Given a set of source files, sets the given property on them."""
    self.out.write('set(')
    self.out.write(property_name)
    self.out.write(' "')
    self.out.write('${')
    self.out.write(property_name)
    self.out.write('} ')
    for value in values:
      self.out.write(cmake_string_escape(value))
      self.out.write(sep)
    self.out.write('")\n\n')

  def write_current_target_property(self, target_name, property_name, values, sep=''):
    """Given a target, sets the given property."""
    self.out.write('set_target_properties(%s PROPERTIES ' % target_name)
    self.out.write(property_name)
    self.out.write(' ')
    for value in values:
      self.out.write('\n  ')
      self.out.write(cmake_string_escape(value))
      self.out.write(sep)
    self.out.write('\n  )\n\n')

  def write_cmake_variable(self, variable_name, prepend=None):
    if prepend:
      self.out.write(prepend)
    self.out.write('${')
    self.out.write(variable_name)
    self.out.write('}')
    

def write_project(project, 
                  cmake_version,
                  compiler_target, 
                  keep_libs, 
                  flavor_name, 
                  parent_action_targets):
  if type(project) != Project:
    return -1
  use_path_prefix = DEFAULT_USE_PATH_PREFIX
  start_target = project.start_target
  if not start_target.cmake_type.is_linkable:
    raise Exception('The target specified in arguments must be a linkable target')
  
  if parent_action_targets == None:
    parent_action_targets = set()
  
  target_list = project.find_all_dependencies(start_target)
  defines = project.find_all_user_defines(compiler_target, target_list)
  include_dirs = project.find_all_include_dirs(target_list)
  shared_targets = project.find_dependent_shared_targets(target_list)
  sources_dict, has_asm = project.find_all_sources(target_list)
  prebuild_actions = project.find_all_prebuild_action_targets(target_list, parent_action_targets)
  full_path_libs, no_path_libs = project.find_all_libs(start_target, target_list, compiler_target, keep_libs)
  all_flags = project.find_custom_flags(start_target, compiler_target)
  target_compile_options = start_target.metadata.target_compile_options
  add_compile_options = start_target.metadata.add_compile_options
  find_and_link_packages = start_target.metadata.find_and_link_packages
  subdirectory_targets = start_target.metadata.subdirectory_targets
  need_strip_symbol = start_target.metadata.need_strip_symbol

  module_path = start_target.gn_name.split(':')[0]
  module_path = module_path[2:]
  path = os.path.join(project.build_path, 'CMakeLists', module_path, 'CMakeLists.txt')
  writer = Writer(path)
  writer.write_header_info(project)
  writer.write_defines(defines)
  if use_path_prefix:
    writer.write_cmake_root_path(module_path)
  writer.write_include_dirs(project, include_dirs, use_path_prefix)
  writer.write_dependent_shared_targets(shared_targets, flavor_name, project, use_path_prefix)
  if (len(sources_dict) > 0):
    writer.write_all_sources(project, sources_dict, start_target.cmake_name, use_path_prefix)
    writer.write_enable_asm(has_asm)
    writer.write_prebuild_actions(prebuild_actions, project, use_path_prefix)
    writer.write_main_target(start_target, prebuild_actions)
    writer.write_target_compile_options(target_compile_options, start_target.output_name)
    writer.write_add_compile_options(add_compile_options)
    writer.write_all_libs(project, full_path_libs, no_path_libs, start_target.output_name, use_path_prefix)
    writer.write_find_package_and_link(start_target, find_and_link_packages)
  writer.write_subdirectory(subdirectory_targets, project, use_path_prefix)
  writer.write_compiler_and_linker_flags(start_target, all_flags)
  writer.write_strip_symbol(need_strip_symbol, start_target.output_name)

  r = 0
  for sub in subdirectory_targets:
    project_json = {}
    project_json['targets'] = project.targets
    project_json['build_settings'] = project.build_settings
    sub_project = Project(project_json, '', sub, cmake_version, project)
    parent_action_targets.update(set(prebuild_actions))
    r |= write_project(sub_project, 
                       cmake_version,
                       compiler_target, 
                       keep_libs, 
                       flavor_name, 
                       parent_action_targets)

  return r

def read_json_file(json_path, project_name, start_target, cmake_version):
  project_json = None
  with open(json_path, 'r') as json_file:
    project_json = json.loads(json_file.read())
  return Project(project_json, project_name, start_target, cmake_version, None)
  

def gn_to_cmake(json_path,
                start_target, 
                cmake_version = DEFAULT_CMAKE_MIN_VERSION,
                project_name = '',
                compiler_target = DEFAULT_GN_COMPILER_TARGET, 
                keep_libs = [], 
                flavor_name = ''
                ):
  project = read_json_file(json_path, project_name, start_target, cmake_version)
  compiler_t = Target(compiler_target, project)
  return write_project(project, 
                       cmake_version,
                       compiler_t, 
                       keep_libs, 
                       flavor_name, 
                       None)

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('--json-path', type=str, required=True, help='GN target json file path.')
  parser.add_argument('--start-target', type=str, required=True, help='The target from which you want to generate CMakeLists')
  parser.add_argument('--cmake-version', type=str,required=False, help='The min version of cmake')
  parser.add_argument('--project-name', type=str,required=False, help='Project name of CMakeLists.txt')
  parser.add_argument('--compiler-target', type=str, required=False, default= '//:gen_basic_compiler_flags', help='The target from which you want to get basic compiler flags, the default is "//:gen_basic_compiler_flags"')
  parser.add_argument('--keep-libs', nargs='+', required=False, help='Basic libs config in buildroot will be removed. The libs in keep-libs list will be filtered out')
  parser.add_argument('--flavor-name', type=str, required=False)
  args = parser.parse_args()
  json_path = args.json_path
  start_target = args.start_target
  cmake_version = args.cmake_version
  project_name = args.project_name
  compiler_target = args.compiler_target
  keep_libs = args.keep_libs
  flavor_name = args.flavor_name

  return gn_to_cmake(json_path, 
                     start_target, 
                     cmake_version, 
                     project_name,
                     compiler_target, 
                     keep_libs, 
                     flavor_name
                     )

if __name__ == "__main__":
  sys.exit(main())